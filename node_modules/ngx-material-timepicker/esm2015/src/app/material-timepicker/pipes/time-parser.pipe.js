import * as tslib_1 from "tslib";
import { Inject, Injectable, Pipe } from '@angular/core';
import { NUMBERING_SYSTEM, TIME_LOCALE } from '../tokens/time-locale.token';
import { TimeUnit } from '../models/time-unit.enum';
import { DateTime } from 'luxon';
let TimeParserPipe = class TimeParserPipe {
    constructor(locale, numberingSystem) {
        this.locale = locale;
        this.numberingSystem = numberingSystem;
    }
    transform(time, timeUnit = TimeUnit.HOUR) {
        if (time == null || time === '') {
            return '';
        }
        if (!isNaN(+time)) {
            return time;
        }
        if (timeUnit === TimeUnit.MINUTE) {
            return this.parseTime(time, 'm', 'minute');
        }
        return this.parseTime(time, 'H', 'hour');
    }
    parseTime(time, format, timeMeasure) {
        const parsedTime = DateTime.fromFormat(String(time), format, {
            numberingSystem: this.numberingSystem,
            locale: this.locale
        })[timeMeasure];
        if (!isNaN(parsedTime)) {
            return parsedTime;
        }
        throw new Error(`Cannot parse time - ${time}`);
    }
};
TimeParserPipe.ctorParameters = () => [
    { type: String, decorators: [{ type: Inject, args: [TIME_LOCALE,] }] },
    { type: String, decorators: [{ type: Inject, args: [NUMBERING_SYSTEM,] }] }
];
TimeParserPipe = tslib_1.__decorate([
    Pipe({
        name: 'timeParser'
    }),
    Injectable(),
    tslib_1.__param(0, Inject(TIME_LOCALE)), tslib_1.__param(1, Inject(NUMBERING_SYSTEM))
], TimeParserPipe);
export { TimeParserPipe };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGltZS1wYXJzZXIucGlwZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25neC1tYXRlcmlhbC10aW1lcGlja2VyLyIsInNvdXJjZXMiOlsic3JjL2FwcC9tYXRlcmlhbC10aW1lcGlja2VyL3BpcGVzL3RpbWUtcGFyc2VyLnBpcGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLElBQUksRUFBaUIsTUFBTSxlQUFlLENBQUM7QUFDeEUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLFdBQVcsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBQzVFLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUNwRCxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sT0FBTyxDQUFDO0FBUWpDLElBQWEsY0FBYyxHQUEzQixNQUFhLGNBQWM7SUFFdkIsWUFBeUMsTUFBYyxFQUFvQyxlQUF1QjtRQUF6RSxXQUFNLEdBQU4sTUFBTSxDQUFRO1FBQW9DLG9CQUFlLEdBQWYsZUFBZSxDQUFRO0lBQ2xILENBQUM7SUFFRCxTQUFTLENBQUMsSUFBcUIsRUFBRSxRQUFRLEdBQUcsUUFBUSxDQUFDLElBQUk7UUFDckQsSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksS0FBSyxFQUFFLEVBQUU7WUFDN0IsT0FBTyxFQUFFLENBQUM7U0FDYjtRQUVELElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUNmLE9BQU8sSUFBSSxDQUFDO1NBQ2Y7UUFFRCxJQUFJLFFBQVEsS0FBSyxRQUFRLENBQUMsTUFBTSxFQUFFO1lBQzlCLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsR0FBRyxFQUFFLFFBQVEsQ0FBQyxDQUFDO1NBQzlDO1FBRUQsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxHQUFHLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFFN0MsQ0FBQztJQUVPLFNBQVMsQ0FBQyxJQUFxQixFQUFFLE1BQWMsRUFBRSxXQUF3QjtRQUM3RSxNQUFNLFVBQVUsR0FBRyxRQUFRLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxNQUFNLEVBQUU7WUFDekQsZUFBZSxFQUFFLElBQUksQ0FBQyxlQUFlO1lBQ3JDLE1BQU0sRUFBRSxJQUFJLENBQUMsTUFBTTtTQUN0QixDQUFDLENBQUMsV0FBVyxDQUFDLENBQUM7UUFFaEIsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsRUFBRTtZQUNwQixPQUFPLFVBQVUsQ0FBQztTQUNyQjtRQUVELE1BQU0sSUFBSSxLQUFLLENBQUMsdUJBQXVCLElBQUksRUFBRSxDQUFDLENBQUM7SUFDbkQsQ0FBQztDQUVKLENBQUE7O3lDQWpDZ0IsTUFBTSxTQUFDLFdBQVc7eUNBQTJCLE1BQU0sU0FBQyxnQkFBZ0I7O0FBRnhFLGNBQWM7SUFKMUIsSUFBSSxDQUFDO1FBQ0YsSUFBSSxFQUFFLFlBQVk7S0FDckIsQ0FBQztJQUNELFVBQVUsRUFBRTtJQUdJLG1CQUFBLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQSxFQUEwQixtQkFBQSxNQUFNLENBQUMsZ0JBQWdCLENBQUMsQ0FBQTtHQUZ6RSxjQUFjLENBbUMxQjtTQW5DWSxjQUFjIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0LCBJbmplY3RhYmxlLCBQaXBlLCBQaXBlVHJhbnNmb3JtIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOVU1CRVJJTkdfU1lTVEVNLCBUSU1FX0xPQ0FMRSB9IGZyb20gJy4uL3Rva2Vucy90aW1lLWxvY2FsZS50b2tlbic7XG5pbXBvcnQgeyBUaW1lVW5pdCB9IGZyb20gJy4uL21vZGVscy90aW1lLXVuaXQuZW51bSc7XG5pbXBvcnQgeyBEYXRlVGltZSB9IGZyb20gJ2x1eG9uJztcblxudHlwZSBUaW1lTWVhc3VyZSA9ICdob3VyJyB8ICdtaW51dGUnO1xuXG5AUGlwZSh7XG4gICAgbmFtZTogJ3RpbWVQYXJzZXInXG59KVxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFRpbWVQYXJzZXJQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG5cbiAgICBjb25zdHJ1Y3RvcihASW5qZWN0KFRJTUVfTE9DQUxFKSBwcml2YXRlIGxvY2FsZTogc3RyaW5nLCBASW5qZWN0KE5VTUJFUklOR19TWVNURU0pIHByaXZhdGUgbnVtYmVyaW5nU3lzdGVtOiBzdHJpbmcpIHtcbiAgICB9XG5cbiAgICB0cmFuc2Zvcm0odGltZTogc3RyaW5nIHwgbnVtYmVyLCB0aW1lVW5pdCA9IFRpbWVVbml0LkhPVVIpOiBudW1iZXIgfCBzdHJpbmcge1xuICAgICAgICBpZiAodGltZSA9PSBudWxsIHx8IHRpbWUgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTmFOKCt0aW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRpbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGltZVVuaXQgPT09IFRpbWVVbml0Lk1JTlVURSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaW1lKHRpbWUsICdtJywgJ21pbnV0ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaW1lKHRpbWUsICdIJywgJ2hvdXInKTtcblxuICAgIH1cblxuICAgIHByaXZhdGUgcGFyc2VUaW1lKHRpbWU6IHN0cmluZyB8IG51bWJlciwgZm9ybWF0OiBzdHJpbmcsIHRpbWVNZWFzdXJlOiBUaW1lTWVhc3VyZSk6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFRpbWUgPSBEYXRlVGltZS5mcm9tRm9ybWF0KFN0cmluZyh0aW1lKSwgZm9ybWF0LCB7XG4gICAgICAgICAgICBudW1iZXJpbmdTeXN0ZW06IHRoaXMubnVtYmVyaW5nU3lzdGVtLFxuICAgICAgICAgICAgbG9jYWxlOiB0aGlzLmxvY2FsZVxuICAgICAgICB9KVt0aW1lTWVhc3VyZV07XG5cbiAgICAgICAgaWYgKCFpc05hTihwYXJzZWRUaW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZFRpbWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBwYXJzZSB0aW1lIC0gJHt0aW1lfWApO1xuICAgIH1cblxufVxuIl19